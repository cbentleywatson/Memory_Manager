// Struct Test
/*
typedef int (*int_int_fp)(int input);

typedef fp_struct_instance
{
	int_int_fp struct_func;
}
int_int_fp_struct;

int_int_fp_struct my_struct;
int dummy_output = 1; // i.e. false
					  // two options: #1 Seperate Dummy:

int dummy_int_to_replace(int a)
{
	return a;
}
int real_funct{int a}
{
	return 0; // i.e. true
}

my_struct.struct_func = dummy_int_to_replace;
// Then Replacement is carried out
int output = my_struct.struct_func(11)
			 // run some test to see if it worked
			 // Option #2: Single Function Reeplacement:

			 int
			 dummy_op_2(int a)
{
	return my_struct.struct_func(int a);
}




// These two check if the functions swapped in. If they did, then 0 is returned after from the second call.
// If they didn't the same function is called, but now it returns 2. The Recursion breaks then,  and we know if it worked
int dummy_op_test(int a)
{
	if (a == 1)
	{
		return my_struct.struct_func(a + 1);
	}
	if (a == 2)
	{
		return -1
	}
}
int test_op(int a)
{
	return 0;
}

// run replacement code


// The all in one function is probably smartest in the general function case

void replace (&a){
	# the copy is a void pointer, but the original is not a void pointer
	struct_funct_typedef * new_type_def_ptr;


	new_type_def_ptr = (func_struct_type) MM_replace("this_libs_name"); // MM_replace always returns a void pointer
	a = *new_type_def_ptr;

	// Or
	// a is the global variable for this object
	a = ((func_struct_type) MM_Replace ("libname") )*
}
Or
	void replace(void){
		func_struct_type_def * temp;
		temp = &func_struct_globa;l
	}


 void* MM_Replace(String lib_name)
	// loading the lib will require allocat
	// will include malloc
	// func_struct_type * temp = (func)

*/
/*
	If struc func can be placed in data and called from there, the struct funct function can be skipped by forcing
	the struct to point to it again
*/


//int output = dummy_op_2(a);


// Load_funcs (the function which is never called)

// Now run the test ons

//



