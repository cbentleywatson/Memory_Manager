A data folder is needed for this to work, ELF is included in there
https://stackoverflow.com/questions/34960383/how-read-elf-header-in-c
http://www.skyfree.org/linux/references/ELF_Format.pdf


mmcpy
https://www.techonthenet.com/c_language/standard_library_functions/string_h/memcpy.php#:~:text=In%20the%20C%20Programming%20Language%2C%20the%20memcpy%20function,s1.%20It%20returns%20a%20pointer%20to%20the%20destination.
https://stackoverflow.com/questions/44944965/filling-of-a-structure-using-memcpy

mmcpy with offsets
https://cboard.cprogramming.com/c-programming/134799-memcpy-part-array-specific-position-different-array.html

It seems like fpic runs fine

Compile a shared library:
gcc -shared -o libhello.so -fPIC hello.c

Default Compiler Flags:
These are stored in idedate.json at the very bottom of the file.

Contents of lib_memory_Manager.ar
Even with a shared object file, ar can effectively store a shared object

Building an executable packer (CRUCIAL?):
https://fasterthanli.me/series/making-our-own-executable-packer/part-17

How a dynamic Linker works:
https://cseweb.ucsd.edu/~gbournou/CSE131/the_inside_story_on_shared_libraries_and_dynamic_loading.pdf

Making Tiny asm stuff

https://www.muppetlabs.com/~breadbox/software/tiny/teensy.html
ELF Header Dissection:
https://0x00sec.org/t/dissecting-and-exploiting-elf-files/7267


Gcc tools for this platform directory:
C:\Users\cbent\.platformio\packages\toolchain-xtensa32\bin

gcc -c can make an object file with a single text section

Using pointers to functions:
https://www.cprogramming.com/tutorial/function-pointers.html

This is where my pointer to pointer code came from:
https://www.reddit.com/r/C_Programming/comments/63wyd7/converting_void_pointers_to_function_pointers/

IDK how the code works.

Explains typedef and how to make function pointers work:
http://www.cs.cmu.edu/~ab/15-123N09/lectures/Lecture%2008%20-%20Function%20Pointers.pdf


Information on using glibc to fill up an elf header data structure:
https://eklitzke.org/position-independent-executables

Update firmware from binaries on a spiffs image:
https://techtutorialsx.com/2019/07/21/esp32-arduino-updating-firmware-from-the-spiffs-file-system/

Tiny ELF:
https://static.lwn.net/images/conf/rtlws-2011/proc/Yong.pdf

Linker Scripting. May contain the final command for centralizing text, data etc. in order:
https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html

PlatformIO's more detailed linker info
https://docs.platformio.org/en/latest/projectconf/advanced_scripting.html


### Successfully Attaching a linker script to a library manifest:

This was placed at the end of Memory_manager_d's library build flags. The linker saw it but it messed every thing else up.


"-Wl,--script='C:\\Users\\cbent\\a.txt'"


### Dead code strip without LTO:

https://gcc.gnu.org/legacy-ml/gcc-help/2003-08/msg00128.html
-Wl,-static -fvtable-gc -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
DEFAULT FLAGS:


 "-fno-rtti -fno-exceptions -std=gnu++11 -fpic -fpermissive -Os -Wall -nostdlib -Wpointer-arith -Wno-error=unused-but-set-variable -Wno-error=unused-variable -mlongcalls -ffunction-sections -fdata-sections -fstrict-volatile-bitfields -Wno-error=deprecated-declarations -Wno-error=unused-function -Wno-unused-parameter -Wno-sign-compare -fstack-protector -fexceptions -Werror=reorder"}

DEADCODESTRIP := -Wl,-static -fvtable-gc -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s

 -Wl,-static
Link against static libraries.  Required for dead-code elimination.

-fvtable-gc
C++ virtual method table instrumented with garbage collection information for the linker.

-fdata-sections
Keeps data in separate data sections, so they can be discarded if unused.

-ffunction-sections
Keeps funcitons in separate data sections, so they can be discarded if unused.

-Wl,--gc-sections
Tell the linker to garbage collect and discard unused sections.

-s
Strip the debug information, so as to make the code as small as possible.  (I presume that you'd want to do this in a dead-code removal build.)

The requirement to link against the static libraries was surprising to me.  But there you go.

HTH,
--Eljay

C:\Users\cbent\.platformio\platforms\espressif32\builder\fvtable-gc'

https://stackoverflow.com/questions/200292/process-for-reducing-the-size-of-an-executable

GCC 4.2.1 manual

LTO ar, nm etc

https://bugzilla.redhat.com/show_bug.cgi?id=1678826




11/9
added flto to the linker and to the 

board_build.ldscript = /path/to/ldscript.ld
Replaces the board scrip

All PIO variables available:
https://github.com/platformio/platformio-core/blob/develop/platformio/builder/main.py

CRUCIAL!!!!!!
You can link a script if you specify the library path first. Or at least you can make this compile
            "-Wl,--script="C:\\Users\\cbent\\a.txt""
            //"-Wl,-C:\Users\cbent\Dropbox",
            //"-Wl,-T a.txt"
            It doesn't like the one above this.


Contains actual code for loading an elf file to run:

http://thomasloven.com/blog/2013/08/Loading-Elf/

Recommended docs Elf File format
http://www.skyfree.org/linux/references/ELF_Format.pdf

    ...
    elf_phead *phead = (elf_phead)&data[elf->ph_offset];
    uint32_t i;
    for(i = 0; i < elf->ph_num; i++)
    {
        if(phead[i].type == ELF_PT_LOAD)
        {
            load_elf_segment(data, &phead[i]);
        }
    }
    return 0;
}
This would also

Esp 32 Loader  Tutorial
https://docs.espressif.com/projects/esp-idf/en/latest/esp32s2/api-guides/linker-script-generation.html

Esp32 Default linker script:
https://github.com/espressif/esp-idf/blob/451ce8a/components/esp_system/ld/esp32s2/sections.ld.in

INSTRUCTION ADDRESSING:

Internal execution RAM is located between       0x4008_0000 and    0x400A_0000
However, the executable address space runs from 0x4008_0000 to     0x407F_FFFF.
Note that the "7" is one place over from the "A" in 
That entire area is accessible by the cache and memory management unit.

Information on storing stack data out side of ROM:

CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY
Allow external memory as an argument to xTaskCreateStatic

Found in: Component config > ESP32-specific > CONFIG_ESP32_SPIRAM_SUPPORT > SPI RAM config

https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-spiram-allow-stack-external-memory


Because some bits of the ESP32 code environment cannot be recompiled with the cache workaround, normally tasks cannot be safely run with their stack residing in external memory; for this reason xTaskCreate (and related task creaton functions) always allocate stack in internal memory and xTaskCreateStatic will check if the memory passed to it is in internal memory. If you have a task that needs a large amount of stack and does not call on ROM code in any way (no direct calls, but also no Bluetooth/WiFi), you can try enable this to cause xTaskCreateStatic to allow tasks stack in external memory.

Default value:
No (disabled) if SPIRAM_USE_MALLOC && CONFIG_ESP32_SPIRAM_SUPPORT

CONFIG_SPIRAM_USE
SPI RAM access method

Found in: Component config > ESP32-specific > CONFIG_ESP32_SPIRAM_SUPPORT > SPI RAM config

The SPI RAM can be accessed in multiple methods: by just having it available as an unmanaged memory region in the CPU’s memory map, by integrating it in the heap as ‘special’ memory needing heap_caps_malloc to allocate, or by fully integrating it making malloc() also able to return SPI RAM pointers.

Available options:
Integrate RAM into memory map (SPIRAM_USE_MEMMAP)

Make RAM allocatable using heap_caps_malloc(…, MALLOC_CAP_SPIRAM) (SPIRAM_USE_CAPS_ALLOC)

Make RAM allocatable using malloc() as well (SPIRAM_USE_MALLOC)


#### This option has to do with avoiding the issue where using the flash cache blocks access to external ram.

https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-spiram-cache-workaround

Put libc’s jump related functions in IRAM

Found in: Component config > ESP32-specific > CONFIG_ESP32_SPIRAM_SUPPORT > SPI RAM config > SPIRAM workaround libraries placement

The functions affected by this option are: longjmp and setjmp. Putting these function in IRAM will allow them to be called when flash cache is disabled but it will also reduce the available size of free IRAM for the user application.

Default value:
Yes (enabled) if CONFIG_SPIRAM_CACHE_WORKAROUND && CONFIG_ESP32_SPIRAM_SUPPORT



11/20 - 5 additional hours

FATAL ERRORS:

### Load_Store_Alignment:
32 bit load from 4 byte aligned address only, 16 from two etc. This probably means any load from 


### Load Prohibited or Store Prohibited:

If ExecV is zero a null ptr was probably used. If the address is ouside of 0x3fxx_xxxx and 0x6xxx_xxxx, the value is garbage


### Instr_Fetch_Prohibited:

CPU could not load this instruction because the instruction address is not in a valid region of instruction ram or ROM. Usually this is caused by attempting to call a function pointer which does not point to valid code. Program counter register register can usually be used as an indicator. It will either be zero ( from a null ptr or around zero due to a null ptr used with an offset addition), or a garbage value (not 0x4xxx_xxxx).



Setting memcopy etc. in IRAM so it can be run while flash cahe is disabled.

https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-spiram-cache-libmem-in-iram


### How to Use External RAM for External Memory: (Actually this just mapped to internal flash ram)


You have to use a bitwise or ( "||" ) with the two types of memory you want, IRAM and external ram. 


heap_caps_malloc(1000, MALLOC_CAP_EXEC || MALLOC_CAP_SPIRAM);

https://gitea.edwinclement08.com/espressif/esp-idf/commit/a3a1cc080e225e3208c210076386152002b625fc

### How To configure ram for use in  a platform IO Project

You use build pla Configuring External RAM: N

-D CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY


-D MALLOC_CAP_SPIRAM

### Configuring FLASH for 

https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/storage/spi_flash.html

Arduino Based library:
https://github.com/Marzogh/SPIMemory/blob/master/README.md

### Mapping External Flash to Address Space:

#include "esp_spi_flash.h"

  #Current Code (Located in Main):
      size_t src_address;
    size_t size;
    spi_flash_mmap_memory_t memory_type;
    const void **out_ptr; // points to the mapped memory region
    spi_flash_mmap_handle_t handle;
    // spi_flash_mmap(src_address, size, SPI_FLASH_MMAP_DATA, out_ptr, handle);
### C++ syntax for fp conversions:

https://en.cppreference.com/w/cpp/language/reinterpret_cast
See item #7's note on function pointer  conversions

    ### Good Example Code:

https://stackoverflow.com/questions/1096341/function-pointers-casting-in-c/1096349

### Casting Pointers to Numeric Values:

There's a data type defined to do this, uint_ptr.
It's special property is that if you turn a ptr into this type then convert it back it 
will always have the same value afterwards. This is portable. 

### Function Pointer Dtructs:

Fuse includes structs made solely of function pointers, with the struct holding 
the type of each function ptr; type def each relevant function and store it in one of these.

### Failure to send exec code to FLASH:
 Turns out the mmap function is one way only. You can't write to a mapped address, you can only read.

###  Calling Assembly functions:

The calls are always 132_r to a spot 4 bytes above the start of the address; the stuff in parens evaluates to a constant to it's lefr

### Setting Entry Symbols:

ENTRY(symbol)  added to the beginning of the script sets the header entry location to equal the symbol. The value put in the header in the offset of that symbol relative to the start of 
the text header.

### Locating the addresses of functions via functions and relative loads:

Its possible to create a function that returns it's own address regardless of it's current location in memory using relative loads and the program counter.

#### KEY: Function Loading to struct:
	Using the L32r relative location system above, it's possible to calculate the correct address of any function if you can call it. You can fill a table of function locations by calling a
	single function thats in the same text segment. Filling in the locations means you can call the subfunctions using the function table returned.

#### KEY: Adding Custom Header Info:
Adding a series of bytes to the .txt section so they can be found by referenceing offsets from entry.

### Linker Script Info:
 I'm looking for the information on creating byte sections
 http://web.mit.edu/rhel-doc/3/rhel-ld-en-3/scripts.html	

https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html


### Program Header Info:
 By adjusting the program header commands, the sections can be split up into logical blocks. With PHDRS specified, there will be two segments corresponding to the data/bss and text segments, in order

### IBM C elf interpreter
https://www.ibm.com/docs/en/zos/2.2.0?topic=file-example-relocating-addresses-within-elf

##E Finding the Location of a function ###
 Given a function found at 44 in in the right side symbol table in objdump which represents the first function in the text segment, the text segment itself will be located at that value 
 + 52 (the size of the elf header) -1

 ### Slides on Relocating stuff:
 http://web.cse.ohio-state.edu/~reeves.92/CSE2421au12/SlidesDay52.pdf

 ### Readable Section Descriptions

 https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/storage/spi_flash.
 
 ### Mapping from SPI flash
 
 html#_CPPv417esp_partition_get24esp_partition_iterator_t

 ### ESP IDF MMAP SOurce Code:
 https://github.com/espressif/esp-idf/blob/master/components/spi_flash/test/test_mmap.c


### The real thing:
 https://github.com/espressif/esp-idf/blob/master/components/spi_flash/flash_mmap.c

 ### Direct Manipulation of MMU Tables:

 https://www.esp32.com/viewtopic.php?f=12&t=4832
Note the spi_flash
rc from spi_flash_cache2phys(0x40800000) = 0x300000
rc from spi_flash_phys2cache(0x300000, inst) = 0x40800000
 
 ### !!!! Included from file dport_reg.h Additionally!

- Mark the function that manipulates the MMU tables with IRAM_ATTR (and prevent it being inlined, if necessary)
- Before writing to the MMU table call spi_flash_disable_interrupts_caches_and_other_cpu();
- After writing to the MMU table call Cache_Flush(0); Cache_Flush(1); spi_flash_enable_interrupts_caches_and_other_cpu();
- Try and do as little as possible while interrupts are disabled (ie don't call printf() or anything like that)

 ### CPU Start -- Includes many powerful functions
 https://github.com/pycom/esp-idf-2.0/blob/master/components/esp32/cpu_start.c

 ### Potential Complete Version Of the Project:
 https://github.com/embedded2014/elf-loader

 ### Forum with Examples; Someone asked about building  very similar system and these are the answers
 https://esp32.com/viewtopic.php?t=4769 

 ### -r On Linker script required to prevent l32r error:
Without including -r in the linker script command, ld will refuse to create a new file.
The error will be l32r which has to do with unknown relocations

#### Repo with a Load Module:
https://github.com/niicoooo/esp32-elfloader
Contains defines for all 45 of the xtensa elf relocation possibilities
loader.c has defintions for some of the relocations, starting at line 172 of loader.c


### Mentions c Code Running From a File Stored Onboard (ESP32 Alexa Demo):

https://www.youtube.com/watch?v=re-dSV_a0tM
This may be useful because it show some helper functions around 3:50 that,

### This is The Video Where he shows the Model from C being implemented:
https://www.youtube.com/watch?v=kZdIO82059E
tensor flow light xxd command will create the c program
# Seems likely that I may Need to Eventually Connect the heap to the dynamically loaded lib; If the  

### Writing Custom Malloc and Free Functions:
http://tharikasblogs.blogspot.com/p/how-to-write-your-own-malloc-and-free.html

#### Map Files?
-Wl,-Map,output.map
https://community.platformio.org/t/generate-a-map-file/1130/6

### More Linker Script Stuff (Might Be repeated above):
board_build.ldscript = /path/to/ldscript.ld
 https://github.com/espressif/esp-idf/blob/master/components/spi_flash/flash_mmap.c



# More On Memory Layouts:
https://docs.espressif.com/projects/esp-idf/en/release-v4.2/esp32/api-reference/system/mem_alloc.html

 ### Load Routine: Need Memory In the Correct physical Address space AND in the Correct  Virtual Address Space
    1. PSRAM Space allocated for both, data, text
     #Malloc_CAP_SPI_RAM
     3F80
    2. Sections mapped to data and exec busses
    3. Sections loaded into their memory slots
    4. Begin to Run code

    # There's a possibility that the exec and MALLOC_CAP_SPIRAM

# Better Forum On the PSRAM Functions:
https://forum.arduino.cc/t/help-me-out-to-create-partition-for-esp32-wroom-32d-8mb/683257/4
https://learn.upesy.com/en/programmation/psram.html
ps_malloc() 

# PS MAlloc:

https://thingpulse.com/esp32-how-to-use-psram/

#Himem API for PSRAM accesss:
https://github.com/espressif/esp-idf/tree/master/examples/system/himem

# ESP Performance:
https://www.esp32.com/viewtopic.php?t=8492

### Shortened MPU MMU Document from espressif: 
Page 87 is the Memory Management stuff, along with page 595, which is more detailed
https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#mpummu

### Forum of professional ARM Peopke:
https://forum.pjrc.com/threads/67939-using-PSRAM-on-Teensy-4-1

They're talking about needing to disable write access in this area (Line 266 of this repo)

https://github.com/PaulStoffregen/cores/blob/9306571409b2fe3f508d1d5a9cf7cbfc9a1c0328/teensy4/startup.c#L266

### ESP32 SPI RAM Auto Configures in PlatformIO
https://community.platformio.org/t/esp32-wrover-platform-ram-size/3313/27

### Write your own Malloc
http://tharikasblogs.blogspot.com/p/how-to-write-your-own-malloc-and-free.html

### Infor On Low Level Cache and Virtual Memory Explained:
In context of accessing external ram as instruction memory
https://esp32.com/viewtopic.php?t=16193

#### Info on Virtual Filesystems in ESP32 and how they can be used
https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/storage/vfs.html

### Overlay manager advice:
https://www.keil.com/support/man/docs/armclang_intro/armclang_intro_pge1466157476779.htm

https://www.geeksforgeeks.org/overlays-in-memory-management/

https://www.google.com/search?q=overlay+methods+in+c&rlz=1C1CHBF_enUS917US917&oq=overlay+methods+in+c&aqs=chrome..69i57j33i22i29i30l9.4966j1j9&sourceid=chrome&ie=UTF-8

https://www.keil.com/support/man/docs/armclang_intro/armclang_intro_pge1466157476779.htm

https://www.tutorialspoint.com/inter_process_communication/inter_process_communication_overlaying_process_image.htm

https://forums.parallax.com/discussion/163970/overlay-code-with-gcc

https://www.microchip.com/forums/m26224.aspx


https://stackoverflow.com/questions/812717/is-there-any-reason-to-use-c-instead-of-c-for-embedded-development

### Setting the VMA
Updated .txt {
    to
.text  : {

    And that set the VMA to 1000
### Setting NOLOAD Option:

.text  : {

    This removes the relocation entries for the text section

    It  Also removes the "LOAD" flag from teh corresponding section header

### Relocation Options:
    Removed -r after the LMA and VMA stuff was assigned.
    It simply removed the relocation tables, added the program header which also moved the start of the sections farther down, so the text section no longer started at file offset 34
### objcopy dumping sections:
../../Linker_Experiments/esp_bin/xtensa-esp32-elf-objcopy.exe simple_lib_d_all_f --dump-section .text=test.txt

The was done with 

### Objcopy dumping sections and NOLOAD:
    Objecopy is currently running WITH AND WITHOUT -r specified and working with both .data and .text.  
    Using NOLOAD flag on .text seems to break the system however. 
    Command
     ../../Linker_Experiments/esp_bin/xtensa-esp32-elf-objcopy.exe simple_lib_d_all_f --dump-section .data=test.txt
     
     #### Remove Sections:
     -R

     ### Set Section Flags:

            --set-section-flags sectionpattern=flags
           Set the flags for any sections matching sectionpattern.  The
           flags argument is a comma separated string of flag names.
           The recognized names are alloc, contents, load, noload,
           readonly, code, data, rom, exclude, share, and debug.  You
           can set the contents flag for a section which does not have
           contents, but it is not meaningful to clear the contents flag
           of a section which does have contents--just remove the
           section instead.  Not all flags are meaningful for all object
           file formats.  In particular the share flag is only
           meaningful for COFF format files and not for ELF format
           files.
#### OVERLAY :
    Changes Section Flags again: Adds relocate for one thing
       CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
       From with no load (I Think)
        ALLOC, READONLY, CODE
        
        CONTENTS, ALLOC, LOAD, READONLY, CODE
        Things can be allocatable, loadable
        If it's allocatable, it needs memory but it doesn't need to be set up in flash
### OLD LINKER SCRIPT COMMENT:
	   /*
	   load_func_struct = . ;
	   start = load_func_struct ;
	   */
	   /*  the function we want to make the entry is assigned to "." and . represents the current address  The entry point is then set equal to the address of . which is now equal to the first address in the section. Since the text section is the only thing in the executable segment the starting function can be loacted by loading the header and finding the correct segment, or by calling the first bytes in the executable code file/segment */
	
	/* These Start and call things are the moset questionable. They're suppo*/
	
	/*call = . ;*/ 
	/*start = load_func_struct +56;*/
	/*start = call ;*/
	/*call;*/

	/* 8c +34 =10C *?
	/*c4-34 =8c;  offset - header size = LMA; Symbol table lists offset as VMA, which means to find the address after cutting, you need to subtract the LMA on segment table from the LMA listed in the symbol table. That gives you 8c -8c, which is zero */   

	/* SNip From Physical offset. R */
	
#### MEMORY:
    # Memory Commands with OVERLAY lead to 

MEMORY
  {
    rom (rx)  : ORIGIN = 0, LENGTH = 256K
    ram (!rx) : org = 0x40000000, l = 4M
	rom_fake (rx)  : ORIGIN = 0, LENGTH = 256K
  }

### Setting the memory to write to is extremely easy; Setting Load memory address and VMA for a Section would appear to place both in the same load address and the VMA

### Getting More Memory From the Second Core
https://hackaday.io/project/174521-bare-metal-second-core-on-esp32/log/182860-build-the-sdk-in-single-core-mode-and-launch-the-second-core-by-hand


# ESP Paritions
https://blog.espressif.com/how-to-use-custom-partition-tables-on-esp32-69c0f3fa89c8



# A server built on an SD card for the ESP-32
https://github.com/espressif/esp-idf/tree/8e3e65a47b7d9b5dc4f52eb56660a748fda1884e/examples/protocols/http_server/restful_server

### Modern Flash Control on the ESP32 Explained:
https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/storage/spi_flash.html

### Linker 
May cause unused sections from my stuff to vanish -fdse

# New Mem protection Tricks:
https://faculty.cc.gatech.edu/~orso/papers/clause.doudalis.orso.prvulovic.pdf

### Prebuilt Set MMU Functions:
/**
  * @brief Set Flash-Cache mmu mapping.
  *        Please do not call this function in your SDK application.
  *
  * @param  int cpu_no : CPU number, 0 for PRO cpu, 1 for APP cpu.
  *
  * @param  int pod : process identifier. Range 0~7.
  *
  * @param  unsigned int vaddr : virtual address in CPU address space.
  *                              Can be IRam0, IRam1, IRom0 and DRom0 memory address.
  *                              Should be aligned by psize.
  *
  * @param  unsigned int paddr : physical address in Flash.
  *                              Should be aligned by psize.
  *
  * @param  int psize : page size of flash, in kilobytes. Should be 64 here.
  *
  * @param  int num : pages to be set.
  *
  * @return unsigned int: error status
  *                   0 : mmu set success
  *                   1 : vaddr or paddr is not aligned
  *                   2 : pid error
  *                   3 : psize error
  *                   4 : mmu table to be written is out of range
  *                   5 : vaddr is out of range
  */
static inline unsigned int IRAM_ATTR cache_flash_mmu_set(int cpu_no, int pid, unsigned int vaddr, unsigned int paddr,  int psize, int num)
{
    extern unsigned int cache_flash_mmu_set_rom(int cpu_no, int pid, unsigned int vaddr, unsigned int paddr,  int psize, int num);

    unsigned int ret;

    DPORT_STALL_OTHER_CPU_START();
    ret = cache_flash_mmu_set_rom(cpu_no, pid, vaddr, paddr, psize, num);
    DPORT_STALL_OTHER_CPU_END();

    return ret;
}
### Current VMA my Sections
0x400D0018


#define DPORT_APP_FLASH_MMU_TABLE ((volatile uint32_t*) 0x3FF12000)
0x400D0018
#### mmap

esp_err_t IRAM_ATTR spi_flash_mmap(size_t src_addr, size_t size, spi_flash_mmap_memory_t memory,
                         const void** out_ptr, spi_flash_mmap_handle_t* out_handle)
{
    esp_err_t ret;
    if (src_addr & INVALID_PHY_PAGE) {
        return ESP_ERR_INVALID_ARG;
    }
    if (src_addr + size > g_rom_flashchip.chip_size) {
        return ESP_ERR_INVALID_ARG;
    }
    // region which should be mapped
    int phys_page = src_addr / SPI_FLASH_MMU_PAGE_SIZE;
    int page_count = (size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE;
    // prepare a linear pages array to feed into spi_flash_mmap_pages
    int *pages = heap_caps_malloc(sizeof(int)*page_count, MALLOC_CAP_INTERNAL);
    if (pages == NULL) {
        return ESP_ERR_NO_MEM;
    }
    for (int i = 0; i < page_count; i++) {
        pages[i] = (phys_page+i);
    }
    ret = spi_flash_mmap_pages(pages, page_count, memory, out_ptr, out_handle);
    free(pages);
    return ret;
}




##### From Cache_sram_mmu.c


unsigned int IRAM_ATTR cache_sram_mmu_set(int cpu_no, int pid, unsigned int vaddr, unsigned int paddr, int psize, int num)
{
    const spi_flash_guard_funcs_t *guard=spi_flash_guard_get();
    if (!guard) {
        //Still starting up; guards not available yet. Use ROM version of code.
        return cache_sram_mmu_set_rom(cpu_no, pid, vaddr, paddr, psize, num);
    }

    unsigned int i,shift,mask_s;
    unsigned int mmu_addr;
    unsigned int mmu_table_val;
    //address check
    if( (ADDRESS_CHECK(vaddr,psize)) || (ADDRESS_CHECK(paddr,psize)) ){
        return MMU_SET_ADDR_ALIGNED_ERROR;
    }
    //psize check
    if(psize == 32) {
        shift  = 15;
        mask_s = 0;
    } else if(psize == 16) {
        shift  = 14;
        mask_s = 1;
    } else if(psize == 8) {
        shift  = 13;
        mask_s = 2;
    } else if(psize == 4) {
        shift  = 12;
        mask_s = 3;
    } else if(psize == 2) {
        shift  = 11;
        mask_s = 4;
    } else {
        return MMU_SET_PAGE_SIZE_ERROR;
    }
    //mmu value
    mmu_table_val = paddr >> shift;
    //mmu_addr
    if(pid == 0 || pid == 1){
        if(vaddr >= PRO_DRAM1_START_ADDR && vaddr < PRO_DRAM1_END_ADDR(psize)){
            mmu_addr = 1152 + ((vaddr & (0x3FFFFF >> mask_s)) >> shift);
        } else{
            return MMU_SET_VADDR_OUT_RANGE;
        }
    } else {
        if(vaddr >= PRO_DRAM1_START_ADDR && vaddr < PRO_DRAM1_END_ADDR(psize)){
            mmu_addr = (1024 + (pid<<7)) + ((vaddr & (0x3FFFFF >> mask_s)) >> shift);
        } else{
            return MMU_SET_VADDR_OUT_RANGE;
        }
    }

    //The MMU registers are implemented in such a way that lookups from the cache subsystem may collide with
    //CPU access to the MMU registers. We use the flash guards to make sure the cache is disabled.
    guard->start();

    //mmu change
    for ( i = 0; i < num; i++){
        *(volatile unsigned int *)(CACHE_MMU_ADDRESS_BASE(cpu_no) + mmu_addr * 4) = mmu_table_val + i; //write table
        mmu_addr++;
    }

    if(cpu_no == 0){
        DPORT_REG_SET_FIELD(DPORT_PRO_CACHE_CTRL1_REG, DPORT_PRO_CMMU_SRAM_PAGE_MODE, mask_s);
    } else {
        DPORT_REG_SET_FIELD(DPORT_APP_CACHE_CTRL1_REG, DPORT_APP_CMMU_SRAM_PAGE_MODE, mask_s);
    }

    guard->end();

    return 0;
}

#### Write to PSRAM Directly from spiram_psram.c


#if CONFIG_SPIRAM_2T_MODE
// use SPI user mode to write psram
static void spi_user_psram_write(psram_spi_num_t spi_num, uint32_t address, uint32_t *data_buffer, uint32_t data_len)
{
    uint32_t addr = (PSRAM_QUAD_WRITE << 24) | (address & 0x7fffff);
    psram_cmd_t ps_cmd;
    ps_cmd.cmdBitLen = 0;
    ps_cmd.cmd = 0;
    ps_cmd.addr = &addr;
    ps_cmd.addrBitLen = 4 * 8;
    ps_cmd.txDataBitLen = 32 * 8;
    ps_cmd.txData = NULL;
    ps_cmd.rxDataBitLen = 0;
    ps_cmd.rxData = NULL;
    ps_cmd.dummyBitLen = 0;

    for(uint32_t i=0; i<data_len; i+=32) {
        psram_clear_spi_fifo(spi_num);
        addr = (PSRAM_QUAD_WRITE << 24) | ((address & 0x7fffff) + i);
        ps_cmd.txData = data_buffer + (i / 4);
        psram_cmd_config(spi_num, &ps_cmd);
        psram_cmd_recv_start(spi_num, ps_cmd.rxData, ps_cmd.rxDataBitLen / 8, PSRAM_CMD_QPI);
    }
    psram_cmd_end(spi_num);
}

// use SPI user mode to read psram
static void spi_user_psram_read(psram_spi_num_t spi_num, uint32_t address, uint32_t *data_buffer, uint32_t data_len)
{
    uint32_t addr = (PSRAM_FAST_READ_QUAD << 24) | (address & 0x7fffff);
    uint32_t dummy_bits = PSRAM_FAST_READ_QUAD_DUMMY + 1;
    psram_cmd_t ps_cmd;
    ps_cmd.cmdBitLen = 0;
    ps_cmd.cmd = 0;
    ps_cmd.addr = &addr;
    ps_cmd.addrBitLen = 4 * 8;
    ps_cmd.txDataBitLen = 0;
    ps_cmd.txData = NULL;
    ps_cmd.rxDataBitLen = 32 * 8;
    ps_cmd.dummyBitLen = dummy_bits + extra_dummy;

    for(uint32_t i=0; i<data_len; i+=32) {
        psram_clear_spi_fifo(spi_num);
        addr = (PSRAM_FAST_READ_QUAD << 24) | ((address & 0x7fffff) + i);
        ps_cmd.rxData = data_buffer + (i / 4);
        psram_cmd_config(spi_num, &ps_cmd);
        psram_cmd_recv_start(spi_num, ps_cmd.rxData, ps_cmd.rxDataBitLen / 8, PSRAM_CMD_QPI);
    }
    psram_cmd_end(spi_num);
}

### Some commentary about memory in embedded systems
https://www.dialog-semiconductor.com/sites/default/files/ai_memories_whitepaper.pdf

### SOmething More Closely Tied to PSRAM Control:

https://blog.pagefault-limited.co.uk/tag/piggyback

### ESP Partition:
    You need to use the esp partition label search to create a struct that can be used to create a partition object
From there a write function can be used to fill the partition directly. 
    The partition struct will also include the physical chip address required to carry out the mapping 