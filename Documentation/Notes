A data folder is needed for this to work, ELF is included in there
https://stackoverflow.com/questions/34960383/how-read-elf-header-in-c
http://www.skyfree.org/linux/references/ELF_Format.pdf


mmcpy
https://www.techonthenet.com/c_language/standard_library_functions/string_h/memcpy.php#:~:text=In%20the%20C%20Programming%20Language%2C%20the%20memcpy%20function,s1.%20It%20returns%20a%20pointer%20to%20the%20destination.
https://stackoverflow.com/questions/44944965/filling-of-a-structure-using-memcpy

mmcpy with offsets
https://cboard.cprogramming.com/c-programming/134799-memcpy-part-array-specific-position-different-array.html

It seems like fpic runs fine

Compile a shared library:
gcc -shared -o libhello.so -fPIC hello.c

Default Compiler Flags:
These are stored in idedate.json at the very bottom of the file.

Contents of lib_memory_Manager.ar
Even with a shared object file, ar can effectively store a shared object

Building an executable packer (CRUCIAL?):
https://fasterthanli.me/series/making-our-own-executable-packer/part-17

How a dynamic Linker works:
https://cseweb.ucsd.edu/~gbournou/CSE131/the_inside_story_on_shared_libraries_and_dynamic_loading.pdf

Making Tiny asm stuff

https://www.muppetlabs.com/~breadbox/software/tiny/teensy.html
ELF Header Dissection:
https://0x00sec.org/t/dissecting-and-exploiting-elf-files/7267


Gcc tools for this platform directory:
C:\Users\cbent\.platformio\packages\toolchain-xtensa32\bin

gcc -c can make an object file with a single text section

Using pointers to functions:
https://www.cprogramming.com/tutorial/function-pointers.html

This is where my pointer to pointer code came from:
https://www.reddit.com/r/C_Programming/comments/63wyd7/converting_void_pointers_to_function_pointers/

IDK how the code works.

Explains typedef and how to make function pointers work:
http://www.cs.cmu.edu/~ab/15-123N09/lectures/Lecture%2008%20-%20Function%20Pointers.pdf


Information on using glibc to fill up an elf header data structure:
https://eklitzke.org/position-independent-executables

Update firmware from binaries on a spiffs image:
https://techtutorialsx.com/2019/07/21/esp32-arduino-updating-firmware-from-the-spiffs-file-system/

Tiny ELF:
https://static.lwn.net/images/conf/rtlws-2011/proc/Yong.pdf

Linker Scripting. May contain the final command for centralizing text, data etc. in order:
https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html

PlatformIO's more detailed linker info
https://docs.platformio.org/en/latest/projectconf/advanced_scripting.html


### Successfully Attaching a linker script to a library manifest:

This was placed at the end of Memory_manager_d's library build flags. The linker saw it but it messed every thing else up.


"-Wl,--script='C:\\Users\\cbent\\a.txt'"


### Dead code strip without LTO:

https://gcc.gnu.org/legacy-ml/gcc-help/2003-08/msg00128.html
-Wl,-static -fvtable-gc -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
DEFAULT FLAGS:


 "-fno-rtti -fno-exceptions -std=gnu++11 -fpic -fpermissive -Os -Wall -nostdlib -Wpointer-arith -Wno-error=unused-but-set-variable -Wno-error=unused-variable -mlongcalls -ffunction-sections -fdata-sections -fstrict-volatile-bitfields -Wno-error=deprecated-declarations -Wno-error=unused-function -Wno-unused-parameter -Wno-sign-compare -fstack-protector -fexceptions -Werror=reorder"}

DEADCODESTRIP := -Wl,-static -fvtable-gc -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s

 -Wl,-static
Link against static libraries.  Required for dead-code elimination.

-fvtable-gc
C++ virtual method table instrumented with garbage collection information for the linker.

-fdata-sections
Keeps data in separate data sections, so they can be discarded if unused.

-ffunction-sections
Keeps funcitons in separate data sections, so they can be discarded if unused.

-Wl,--gc-sections
Tell the linker to garbage collect and discard unused sections.

-s
Strip the debug information, so as to make the code as small as possible.  (I presume that you'd want to do this in a dead-code removal build.)

The requirement to link against the static libraries was surprising to me.  But there you go.

HTH,
--Eljay

C:\Users\cbent\.platformio\platforms\espressif32\builder\fvtable-gc'

https://stackoverflow.com/questions/200292/process-for-reducing-the-size-of-an-executable

GCC 4.2.1 manual

LTO ar, nm etc

https://bugzilla.redhat.com/show_bug.cgi?id=1678826




11/9
added flto to the linker and to the 

board_build.ldscript = /path/to/ldscript.ld
Replaces the board scrip

All PIO variables available:
https://github.com/platformio/platformio-core/blob/develop/platformio/builder/main.py

CRUCIAL!!!!!!
You can link a script if you specify the library path first. Or at least you can make this compile
            "-Wl,--script="C:\\Users\\cbent\\a.txt""
            //"-Wl,-C:\Users\cbent\Dropbox",
            //"-Wl,-T a.txt"
            It doesn't like the one above this.


Contains actual code for loading an elf file to run:

http://thomasloven.com/blog/2013/08/Loading-Elf/

Recommended docs Elf File format
http://www.skyfree.org/linux/references/ELF_Format.pdf

    ...
    elf_phead *phead = (elf_phead)&data[elf->ph_offset];
    uint32_t i;
    for(i = 0; i < elf->ph_num; i++)
    {
        if(phead[i].type == ELF_PT_LOAD)
        {
            load_elf_segment(data, &phead[i]);
        }
    }
    return 0;
}
This would also

Esp 32 Loader  Tutorial
https://docs.espressif.com/projects/esp-idf/en/latest/esp32s2/api-guides/linker-script-generation.html

Esp32 Default linker script:
https://github.com/espressif/esp-idf/blob/451ce8a/components/esp_system/ld/esp32s2/sections.ld.in

INSTRUCTION ADDRESSING:

Internal execution RAM is located between       0x4008_0000 and    0x400A_0000
However, the executable address space runs from 0x4008_0000 to     0x407F_FFFF.
Note that the "7" is one place over from the "A" in 
That entire area is accessible by the cache and memory management unit.

Information on storing stack data out side of ROM:

CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY
Allow external memory as an argument to xTaskCreateStatic

Found in: Component config > ESP32-specific > CONFIG_ESP32_SPIRAM_SUPPORT > SPI RAM config

https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-spiram-allow-stack-external-memory


Because some bits of the ESP32 code environment cannot be recompiled with the cache workaround, normally tasks cannot be safely run with their stack residing in external memory; for this reason xTaskCreate (and related task creaton functions) always allocate stack in internal memory and xTaskCreateStatic will check if the memory passed to it is in internal memory. If you have a task that needs a large amount of stack and does not call on ROM code in any way (no direct calls, but also no Bluetooth/WiFi), you can try enable this to cause xTaskCreateStatic to allow tasks stack in external memory.

Default value:
No (disabled) if SPIRAM_USE_MALLOC && CONFIG_ESP32_SPIRAM_SUPPORT

CONFIG_SPIRAM_USE
SPI RAM access method

Found in: Component config > ESP32-specific > CONFIG_ESP32_SPIRAM_SUPPORT > SPI RAM config

The SPI RAM can be accessed in multiple methods: by just having it available as an unmanaged memory region in the CPU’s memory map, by integrating it in the heap as ‘special’ memory needing heap_caps_malloc to allocate, or by fully integrating it making malloc() also able to return SPI RAM pointers.

Available options:
Integrate RAM into memory map (SPIRAM_USE_MEMMAP)

Make RAM allocatable using heap_caps_malloc(…, MALLOC_CAP_SPIRAM) (SPIRAM_USE_CAPS_ALLOC)

Make RAM allocatable using malloc() as well (SPIRAM_USE_MALLOC)


#### This option has to do with avoiding the issue where using the flash cache blocks access to external ram.

https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-spiram-cache-workaround

Put libc’s jump related functions in IRAM

Found in: Component config > ESP32-specific > CONFIG_ESP32_SPIRAM_SUPPORT > SPI RAM config > SPIRAM workaround libraries placement

The functions affected by this option are: longjmp and setjmp. Putting these function in IRAM will allow them to be called when flash cache is disabled but it will also reduce the available size of free IRAM for the user application.

Default value:
Yes (enabled) if CONFIG_SPIRAM_CACHE_WORKAROUND && CONFIG_ESP32_SPIRAM_SUPPORT



11/20 - 5 additional hours

FATAL ERRORS:

### Load_Store_Alignment:
32 bit load from 4 byte aligned address only, 16 from two etc. This probably means any load from 


### Load Prohibited or Store Prohibited:

If ExecV is zero a null ptr was probably used. If the address is ouside of 0x3fxx_xxxx and 0x6xxx_xxxx, the value is garbage


### Instr_Fetch_Prohibited:

CPU could not load this instruction because the instruction address is not in a valid region of instruction ram or ROM. Usually this is caused by attempting to call a function pointer which does not point to valid code. Program counter register register can usually be used as an indicator. It will either be zero ( from a null ptr or around zero due to a null ptr used with an offset addition), or a garbage value (not 0x4xxx_xxxx).



Setting memcopy etc. in IRAM so it can be run while flash cahe is disabled.

https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-spiram-cache-libmem-in-iram


### How to Use External RAM for External Memory: (Actually this just mapped to internal flash ram)


You have to use a bitwise or ( "||" ) with the two types of memory you want, IRAM and external ram. 


heap_caps_malloc(1000, MALLOC_CAP_EXEC || MALLOC_CAP_SPIRAM);

https://gitea.edwinclement08.com/espressif/esp-idf/commit/a3a1cc080e225e3208c210076386152002b625fc

### How To configure ram for use in  a platform IO Project

You use build pla Configuring External RAM: N

-D CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY


-D MALLOC_CAP_SPIRAM

### Configuring FLASH for 

https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/storage/spi_flash.html

Arduino Based library:
https://github.com/Marzogh/SPIMemory/blob/master/README.md

### Mapping External Flash to Address Space:

#include "esp_spi_flash.h"

  #Current Code (Located in Main):
      size_t src_address;
    size_t size;
    spi_flash_mmap_memory_t memory_type;
    const void **out_ptr; // points to the mapped memory region
    spi_flash_mmap_handle_t handle;
    // spi_flash_mmap(src_address, size, SPI_FLASH_MMAP_DATA, out_ptr, handle);
### C++ syntax for fp conversions:

https://en.cppreference.com/w/cpp/language/reinterpret_cast
See item #7's note on function pointer  conversions

    ### Good Example Code:

https://stackoverflow.com/questions/1096341/function-pointers-casting-in-c/1096349

### Casting Pointers to Numeric Values:

There's a data type defined to do this, uint_ptr.
It's special property is that if you turn a ptr into this type then convert it back it 
will always have the same value afterwards. This is portable. 

### Function Pointer Dtructs:

Fuse includes structs made solely of function pointers, with the struct holding 
the type of each function ptr; type def each relevant function and store it in one of these.

### Failure to send exec code to FLASH:
 Turns out the mmap function is one way only. You can't write to a mapped address, you can only read.

###  Calling Assembly functions:

The calls are always 132_r to a spot 4 bytes above the start of the address